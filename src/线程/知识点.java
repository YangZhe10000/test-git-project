package 线程;

public class 知识点 {
    /*
    * 什么是进程? 什么是线程?
    * 进程是一个应用程序。
    * 线程是一个进程中的执行场景/执行单元
    * 一个进程可以启动多个线程
    *
    * 注意:进程A和进程B的内存独立不共享
    *      线程A和线程B 在java语言中 堆内存和方法去内存共享
    *      栈内存不共享 一个线程一个栈
    *
    * java语言中 实现线程有三种方式
    * java支持多线程机制,并且java已经实现了多线程,我们只需要继承即可
    * 第一种: 编写一个类,直接继承java.lang.Thread
    * 第二种: 编写一个类,实现java.lang.Runnable接口,实现run方法
    *
    *
    * synchronized(线程安全)共有三种写法
    * 第一种:同步代码块
    * 灵活
    * synchronized(线程共享对象){
    *   同步代码块
    * }
    *
    * 第二种:在实例方法上使用synchronized表示共享对象一定是this
    * 并且同步代码块是整个方法体
    *
    * 第三种:在静态方法上使用synchronized
    * 表示找类锁 类锁永远只有一把 就算创建了100个对象 类锁也只有一把
    * 对象锁是一个对象一把锁 一百个对象就有一百把锁
    *
    * 类锁是保证静态变量的安全
    *
    *
    * 如何解决线程安全问题
    * synchronized会让程序的执行效率降低,用户体验不好。系统的用户吞吐量低
    * 用户体验差 在不得已的情况下再选择线程同步机制
    *
    * 第一种方案:尽量使用局部变量代替实例变量和静态变量。
    * 第二种方案:如果必须是实例变量,那么可以考虑创建多个对象,这样实例变量的内存就不共享了
    * (一个线程对应一个对象)
    * 第三种方式:如果不能使用局部变量,对象也不能创建多个,这个时候就只能
    * 使用synchronized了 线程同步机制,典型的就是抢票系统
    *
    * 守护线程:
    * java语言中线程分为两大类
    * 一类是:用户现场
    * 一类是:守护线程
    * 其中具有代表性的就是:垃圾回收线程
    *
    * 守护线程特点:
    * 一般守护线程就是一个死循环,所有的用户线程只要结束,守护线程就会自动结束
    *
    * 注意:主线程Main方法是一个用户线程
    *
    *
    * 关于Object类中的wait和notify方法(生产者消费者模式)
    * 第一: wait和notify 不是线程对象的方法,是java中任何一个java对象都有
    * 的方法,因为这两个方法是Object类中自带的。
    *
    * wait方法和notify方法不是通过线程对象调用,
    * 不是这样的: t.wait(),也不是这样的: t.notify() 不对。
    *
    * 第二: wait()方法作用
    * Object o=new Object();
    * o.wait();
    * 表示 让正在o对象上活动的线程进入等待状态,无期限等待 知道被唤醒
    *
    * 第三: notify方法作用
    * 唤醒在o对象上等待的线程
    *
    * 还有一个notifyAll()方法 唤醒o对象所有等待的线程
    *
    * o.wait方法会让正在o对象上活动的当前线程进入等待状态
    * 并且释放之前占有的o对象的锁
    *
    * o.notify方法只会通知,不会释放之前占有的o对象的锁
    *
    *
    *
    * */
}
